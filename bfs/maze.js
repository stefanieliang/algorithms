/**
 * 小哼解救小哈。
 * 迷宫由`n`行`m`列的单元格组成（`n` 和 `m` 都小于等于50），每个单元格要么是空地，要么是障碍物。
 * 注意障碍物是不能走的，且不能走到迷宫之外。
 * 你的任务是帮助小哼找到一条从迷宫的**起点**通往小哈所在位置的最短路径。
 */

//  -----------------------------z这个还没写出来呢--------------------------

// 初始化一个5行4列的迷宫，1表示障碍物
let n = 5,
    m = 4;
let map = [
    [0, 0, 1, 0],
    [0, 0, 0, 0],
    [0, 0, 1, 0],
    [0, 1, 0, 0],
    [0, 0, 0, 1]
]
// 小哈所在的位置
let p = 3,
    q = 2;


// 用来标记迷宫上某一点有没有走过，1表示走过
let book = [
    [0, 0, 0, 0],
    [0, 0, 0, 0],
    [0, 0, 0, 0],
    [0, 0, 0, 0],
    [0, 0, 0, 0]
]

function Note({
    x,
    y,
    s
}) {
    this.x = x; // 横坐标
    this.y = y; // 纵坐标
    this.s = s; // 步数
}

let que = [];
// for (let i = 0; i < 2500; i++) {
//     que.push({
//         x: 0,
//         y: 0,
//         s: 0
//     })
// }


let bfs = function (x, y, s) {
    // 下一步是四种走法
    let next = [
        [0, 1], // 向右走
        [1, 0], // 向下走
        [0, -1], // 向左走
        [-1, 0] // 向上走
    ]

    let tx, ty, k, flag;

    // 往队列中插入迷宫入口坐标
    que.push({
        x: x,
        y: y,
        s: s
    });
    book[x][y] = 1;

    flag = 0; //用于标记是否到达终点，0未到达，1到达

    // 当队列不为空的时候循环
    while (que.length) {
        let len = que.length;
        // 循环下一步的四种走法
        for (k = 0; k <= 3; k++) {

            // 计算下一点的坐标
            tx = que[len - 1].x + next[k][0];
            ty = que[len - 1].y + next[k][1];

            // 越界退出
            if (tx < 0 || tx > n - 1 || ty < 0 || ty > m - 1) {
                continue; // !!注意，仅需跳出本次循环即可
            }

            // 判断有效点，即该点不是障碍物 && 未走过
            if (map[tx][ty] == 0 && book[tx][ty] == 0) {
                book[tx][ty] == 1; // 把这个点标记为已经走过，!!注意宽度搜索每个点只需入队一次（与深度搜索不同），不需要将 book 数组还原

                // 插入新的点到队列中
                que.push({
                    x: tx,
                    y: ty,
                    s: que[0].s + 1
                });
            }

            // 到达终点
            if (tx == p && ty == q) {
                flag = 1;
                break; // 任务结束，退出循环
            }
        }
        if (flag == 1) {
            break;
        }
        que.shift()
    }
    console.log("找到小哈需要走的最短路径：：", que[len].s - 1)
}
bfs(0, 0, 0);