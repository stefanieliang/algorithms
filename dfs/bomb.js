/**
 * 炸弹人
 * 
 */


// 初始化一个13行13列的迷宫，#表示墙，G表示敌人，.表示空地
let n = 13,
    m = 13;
let map = [
    ['#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#'],
    ['#', 'G', 'G', '.', 'G', 'G', 'G', '#', 'G', 'G', 'G', '.', '#'],
    ['#', '#', '#', '.', '#', 'G', '#', 'G', '#', 'G', '#', 'G', '#'],
    ['#', '.', '.', '.', '.', '.', '.', '.', '#', '.', '.', 'G', '#'],
    ['#', 'G', '#', '.', '#', '#', '#', '.', '#', 'G', '#', 'G', '#'],
    ['#', 'G', 'G', '.', 'G', 'G', 'G', '.', '#', '.', 'G', 'G', '#'],
    ['#', 'G', '#', '.', '#', 'G', '#', '.', '#', '.', '#', '.', '#'],
    ['#', '#', 'G', '.', '.', '.', 'G', '.', '.', '.', '.', '.', '#'],
    ['#', 'G', '#', '.', '#', 'G', '#', '#', '#', '.', '#', 'G', '#'],
    ['#', '.', '.', '.', 'G', '#', 'G', 'G', 'G', '.', 'G', 'G', '#'],
    ['#', 'G', '#', '.', '#', 'G', '#', 'G', '#', '.', '#', 'G', '#'],
    ['#', 'G', 'G', '.', 'G', 'G', 'G', '#', 'G', '.', 'G', 'G', '#'],
    ['#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#']
]

// 用来标记迷宫上某一点有没有走过，1表示走过
let book = [
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
]
let max = 0,
    mx, my;

let dfs = function (x, y) {
    // 下一步是四种走法
    let next = [
        [0, 1], // 向右走
        [1, 0], // 向下走
        [0, -1], // 向左走
        [-1, 0] // 向上走
    ]

    let tx, ty, k, sum = 0;

    sum = getNum(x, y);
    if (sum > max) {
        max = sum;
        mx = x; // 记录当前点的坐标
        my = y;
    }

    // 循环下一步的四种走法
    for (k = 0; k <= 3; k++) {

        // 计算下一点的坐标
        tx = x + next[k][0];
        ty = y + next[k][1];

        // 越界退出
        if (tx < 0 || tx > n - 1 || ty < 0 || ty > m - 1) {
            continue; // !!注意，仅需跳出本次循环即可
        }

        // 判断有效点，即该点是空地 && 未走过
        if (map[tx][ty] == '.' && book[tx][ty] == 0) {
            book[tx][ty] = 1; // 标记该点走过
            dfs(tx, ty); // 尝试下一点
            // book[tx][ty] = 0; // 取消这个点的标记-----这一行不执行也可以
        }
    }

}
dfs(3, 3);
console.log(`将炸弹放在（${mx},${my}）处，最多可消灭 ${max} 个敌人`)


// 【帮助方法】计算每个点上可消除的敌人数
function getNum(i, j) {
    let sum, x, y;
    sum = 0;

    // 向上统计可以消灭的敌人数
    x = i;
    y = j;
    while (map[x][y] != '#') { // 判断如果不是墙就继续
        if (map[x][y] == 'G') { // 如果是敌人，则计数
            sum++;
        }
        x--; // 继续向上统计
    }

    // 向下统计可以消灭的敌人数
    x = i;
    y = j;
    while (map[x][y] != '#') { // 判断如果不是墙就继续
        if (map[x][y] == 'G') { // 如果是敌人，则计数
            sum++;
        }
        x++; // 继续向下统计
    }

    // 向左统计可以消灭的敌人数
    x = i;
    y = j;
    while (map[x][y] != '#') { // 判断如果不是墙就继续
        if (map[x][y] == 'G') { // 如果是敌人，则计数
            sum++;
        }
        y--; // 继续向左统计
    }

    // 向右统计可以消灭的敌人数
    x = i;
    y = j;
    while (map[x][y] != '#') { // 判断如果不是墙就继续
        if (map[x][y] == 'G') { // 如果是敌人，则计数
            sum++;
        }
        y++; // 继续向右统计
    }
    return sum;
}