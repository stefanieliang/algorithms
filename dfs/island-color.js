/** 
 * 着色法改造
 * 
 * 小哼通过秘密方法得到一张不完整的钓鱼岛航拍地图。
 * 钓鱼岛由一个主岛和一些附属岛屿组成，小哼决定去钓鱼岛探险。
 * 10*10的二维矩阵就是钓鱼岛的航拍地图。
 * 图中的数字表示海拔，0表示海洋，1~9都表示陆地。
 * 小哼的飞机将会降落在(6,8)处，现在需要计算出小哼降落地所在岛的面积（即有多少个格子）。
 * 注意此处我们把与小哼降落点上下左右相连接的陆地均视为同一岛屿。
 */


// 初始化一个10行10列的岛屿，0表示海洋，1~9都表示陆地
let n = 10,
    m = 10;
let map = [
    [1, 2, 1, 0, 0, 0, 0, 0, 2, 3],
    [3, 0, 2, 0, 1, 2, 1, 0, 1, 2],
    [4, 0, 1, 0, 1, 2, 3, 2, 0, 1],
    [3, 2, 0, 0, 0, 1, 2, 4, 0, 0],
    [0, 0, 0, 0, 0, 0, 1, 5, 3, 0],
    [0, 1, 2, 1, 0, 1, 5, 4, 3, 0],
    [0, 1, 2, 3, 1, 3, 6, 2, 1, 0],
    [0, 0, 3, 4, 8, 9, 7, 5, 0, 0],
    [0, 0, 0, 3, 7, 8, 6, 0, 1, 2],
    [0, 0, 0, 0, 0, 0, 0, 0, 1, 0]
]

// 用来标记岛屿上某一点有没有走过，1表示走过
let book = [
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
]

let sum;

let dfs = function (x, y, color) {
    // 下一步是四种走法
    let next = [
        [0, 1], // 向右走
        [1, 0], // 向下走
        [0, -1], // 向左走
        [-1, 0] // 向上走
    ]

    let tx, ty, k;

    map[x][y] = color; // !!对map[x][y]这个格子进行染色

    // 循环下一步的四种走法
    for (k = 0; k <= 3; k++) {

        // 计算下一点的坐标
        tx = x + next[k][0];
        ty = y + next[k][1];

        // 越界退出
        if (tx < 0 || tx > n - 1 || ty < 0 || ty > m - 1) {
            continue; // !!注意，仅需跳出本次循环即可
        }

        // 判断有效点，即该点不是海洋 && 未走过
        if (map[tx][ty] > 0 && book[tx][ty] == 0) {
            sum++;
            book[tx][ty] = 1; // 标记该点走过
            dfs(tx, ty, color); // 尝试下一点
            // book[tx][ty] = 0; // 取消这个点的标记，不需要
        }
    }

}

book[5][7] = 1;
sum = 1;
let color = -1;
dfs(5, 7, color);


console.log("降落所在的岛屿面积：：", sum, map)