/** 
 * 一个题目：手中有编号为1~9的九张扑克牌，排列使得`[][][]+[][][]=[][][]`成立，注意A+B=C和B+A=C属于同一种组合，求一共有多少种组合？
 */


// 枚举法（暴力解）
let enumeration = function () {
    let a, b, c, d, e, f, g, h, i, total = 0;
    for (a = 1; a <= 9; a++) { // 第一个数的百位
        for (b = 1; b <= 9; b++) { // 第一个数的十位
            for (c = 1; c <= 9; c++) { // 第一个数的个位

                for (d = 1; d <= 9; d++) { // 第二个数的百位
                    for (e = 1; e <= 9; e++) { // 第二个数的十位
                        for (f = 1; f <= 9; f++) { // 第二个数的个位

                            for (g = 1; g <= 9; g++) { // 第三个数的百位
                                for (h = 1; h <= 9; h++) { // 第三个数的十位
                                    for (i = 1; i <= 9; i++) { // 第三个数的个位

                                        if (a != b && a != c && a != d && a != e && a != f && a != g && a != h && a != i &&
                                            b != c && b != d && b != e && b != f && b != g && b != h && b != i &&
                                            c != d && c != e && c != f && c != g && c != h && c != i &&
                                            d != e && d != f && d != g && d != h && d != i &&
                                            e != f && e != g && e != h && e != i &&
                                            f != g && f != h && f != i &&
                                            g != h && g != i &&
                                            h != i &&
                                            (a * 100 + b * 10 + c) + (d * 100 + e * 10 + f) == g * 100 + h * 10 + i) {
                                            total++;
                                        }

                                    }
                                }
                            }

                        }
                    }
                }

            }
        }
    }
    return total / 2
}
console.log('枚举法（暴力解）::', enumeration())

// 标记法（用 book[] 来解决互不相等的问题）
let bookExec = function () {
    let a = new Array(10),
        i,
        total = 0,
        book = new Array(10),
        sum;
    for (a[1] = 1; a[1] <= 9; a[1]++) { // 第一个数的百位
        for (a[2] = 1; a[2] <= 9; a[2]++) { // 第一个数的十位
            for (a[3] = 1; a[3] <= 9; a[3]++) { // 第一个数的个位

                for (a[4] = 1; a[4] <= 9; a[4]++) { // 第二个数的百位
                    for (a[5] = 1; a[5] <= 9; a[5]++) { // 第二个数的十位
                        for (a[6] = 1; a[6] <= 9; a[6]++) { // 第二个数的个位

                            for (a[7] = 1; a[7] <= 9; a[7]++) { // 第三个数的百位
                                for (a[8] = 1; a[8] <= 9; a[8]++) { // 第三个数的十位
                                    for (a[9] = 1; a[9] <= 9; a[9]++) { // 第三个数的个位

                                        book.fill(0); // 初始化 book[]
                                        for (i = 1; i <= 9; i++) {
                                            book[a[i]] = 1; // 如果某个数出现过就标记
                                        }
                                        // 统计出现了多少个不同的数
                                        sum = 0;
                                        for (i = 1; i <= 9; i++) {
                                            sum += book[i]
                                        }

                                        // 如果正好出现9个不同的数，且满足等式条件
                                        if (sum == 9 && (a[1] * 100 + a[2] * 10 + a[3]) + (a[4] * 100 + a[5] * 10 + a[6]) == (a[7] * 100 + a[8] * 10 + a[9])) {
                                            total++;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    return total / 2
}
console.log('标记法::', bookExec()) // 执行发现，标记法好慢哦！

// 递归（深度优先遍历搜索）
let a = new Array(10),
    book = new Array(10).fill(0),
    total = 0;
let dfs = function (step = 1) {
    let i;
    if (step == 10) { // 站在了第十个盒子前，说明前9个盒子已装好扑克牌
        if ((a[1] * 100 + a[2] * 10 + a[3]) + (a[4] * 100 + a[5] * 10 + a[6]) == (a[7] * 100 + a[8] * 10 + a[9])) {
            total++;
        }
    }
    // 此时站在第step个盒子面前，该放哪个扑克牌呢？
    // 按照1，2，...n一一尝试
    for (i = 1; i <= 9; i++) {
        if (book[i] == 0) { // 说明牌i还在手上
            a[step] = i; // 将牌i放入第step个盒子中
            book[i] = 1; // 标记牌i已不在手上

            dfs(step + 1); // 走到下一个盒子面前，递归
            book[i] = 0; // 一定要将刚才尝试的牌收回！！
        }
    }
}
dfs();
console.log('递归（深度优先遍历搜索）::', total / 2)